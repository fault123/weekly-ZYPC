#   内存管理器(ptmalloc)的学习
##  chunk的具体实现
```C
struct malloc_chunk
{
    INTERNAL_SIZE_T mchunk_prev_size;  // 如果前面一个物理相邻的堆块是空闲的, 则表示其大小, 否则用于储存前一个堆块的数据
    INTERNAL_SIZE_T mchunk_size;       // 当前chunk的大小, 低三位作为flag, 意义如下:
    /*
        A : 倒数第三位表示当前chunk是否属于主线程:1表示不属于主线程, 0表示属于主线程
        M : 倒数第二位表示当前chunk是从mmap(1)[多线程]分配的，还是从brk(0)[子线程]分配的
        P : 最低为表示前一个chunk是否在使用中, 1表示在使用, 0表示是空闲的
            通常堆中的第一个堆块的P位是1, 以便于防止访问前面的非法内存
    */

    /*
        1.真正的内存从这里开始分配
        2.malloc之后这些指针没有用,这时存放的是数据
        3.只有在free之后才有效。
    */
 
    struct  malloc_chunk*   fd;             // 当chunk空闲时才有意义,记录后一个空闲chunk的地址
    struct  malloc_chunk*   bk;             // 同上,记录前一个空闲chunk的地址
 
    /* 仅用于较大的块 */
    struct  malloc_chunk*   fd_nextsize;    // 当前chunk为largebin时才有意义，指向比当前chunk大的第一个空闲chunk
    struct  malloc_chunk*   bk_nextsize;    // 指向比当前chunk小的第一个空闲堆块
};
```
>   堆的大小必须是2*SIZE_SZ的整数倍
> *  32位:SIZE_SZ=4, 因此堆大小为8的整数倍
> *  64位:SIZE_SZ=8, 因此堆大小为16的整数倍

## 堆空闲管理结构(bins)
####   fast bin
>   32位下存放0x10~0x40字节的堆块
>   64位下存放0x20~0x80字节的堆块
>   fast bin按单链表结构, fd指向下一堆块, 采用先进先出模式(FIFO机制)
>   防止释放时对fast bin合并, 堆块的p标志位为1

#### small bin
>    32位下存放0x10~0x400字节的堆块
>    64位下存放0x20~0x800字节的堆块
>    双向链表

#### large bin
>   保存更大的堆块

#### unsorted bin
>   存放刚释放的堆块以及大堆块释放后的堆块

#### tcache( >=glibc 2.26 )
>   tcache是一个线程特定的数据结构, 每个线程都有自己的tcache, 它包含了一组tcache bin
*   tcache的两个重要的结构体如下:
```C
// 链接空闲的chunk结构体
typedef struct tcache_entry
{
    // next指向下一个具有相同大小的chunk
    // 与fast bin不同的是, chunk的fd指向的是下一个chunk的data部分
    struct tcache_entry *next;
} tcache_entry;

// 每个线程都会有一个tcache_perthread_struct用于管理tcache链表
// 这个结构体位于heap段的起始位置
typedef struct tcache_perthread_struct
{
    // counts记录了tcache_entry链上空闲chunk的数量
    // 每条tcache_entry链最多可以有7个chunk
    char counts[TCACHE_MAX_BINS];
    
    // 用单向链表的方式链接了相同大小的处于空闲状态的chunk
    tcache_entry *entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;
```
>   TCACHE_MAX_BINS的默认大小是64


##  malloc过程
*   对齐计算出最终要分配的size
*   检查size是否符合fast bin的范围, 若符合则继续检查fast bin中的size大小的那条链是否存在空闲堆块, 如果存在则分配, 否则继续下一步
*   检查size是否符合small bin的范围, 若符合则继续检查small bin中的size大小的那条链是否存在空闲堆块, 如果存在则分配,否则继续下一步
*   检擦size是否符合large bin大小, 若符合则调用malloc_consolidate函数对fast bin中所有堆块进行合并
> * 遍历fast bin中的所有堆块
> * 对于每一个堆块，它会清除其下一个堆块的P标志位
> * 尝试将当前的内存块和其下一个内存块进行合并
> * 将合并后的内存块放入unsorted bin中
*   然后在small bin和large bin中找到合适的size大小的块, 若找到了则切割该堆块, 并将多余部分放入unsorted bin(或者last remainder chunk, 这取决于剩余部分的大小以及当前的内存分配策略)
*   如果找不到合适的, 检查top chunk的大小是否符合size, 若是则分配前面一部分, 并重新设置top chunk, 否则调用malloc_malloc_consolidate函数对对fast bin中的所有堆块进行合并, 若依然不够, 则借助系统调用来获取新空间进行分配, 若依然无法满足size, 则返回失败


##  free过程
*   free时首先检查地址是否对齐, 并根据size找到下一堆块位置
*   检查释放的size是否满足fast bin, 若满足则直接放入fast bin并保持下一堆块的P标志位为1(避免前后堆块释放时将其合并), 否则继续下一步
*   若本堆块的P标志位为0(表示上一堆块处于空闲状态)利用pre_size找到上一堆块的开头将其从bin中摘除, 并合并这两个堆块
*   根据size找到下一个堆块, 如果是top chunk那么直接合并到top chunk中, 否则检查是否为释放状态(下一个堆块的下一个堆块的P标志位是否为0), 若是则将其从bin中摘除然后合并
*   得到的最终堆块放入unsorted bin中
>   注意 : 合并时只向前或向后合并相邻的堆块

