一、加密原理

密钥生成：

选择两个不同的大素数p和q。

计算它们的乘积n = p * q，作为RSA的模数。

计算欧拉函数φ(n) = (p-1)*(q-1)，表示小于n且与n互质的正整数的个数。

选择一个整数e，满足1 < e < φ(n)，且e与φ(n)互质。e作为公钥的一部分，用于加密数据。

计算整数d，满足(d * e)除以φ(n)的余数为1。d作为私钥的一部分，用于解密数据。

加密：

将明文消息M转换为整数m，使得0 ≤ m < n。

使用公钥(e, n)对m进行加密，计算密文C = m^e mod n。

解密：

使用私钥(d, n)对密文C进行解密，计算明文消息M = C^d mod n

二、Python

1、from Crypto.Util.number import*常用函数：

getPrime(bits, randfunc=None)：生成一个指定位数的随机素数。

参数 bits 指定了素数的位数。

参数 randfunc 是一个可选的随机数生成函数，默认为 Crypto.Random.get_random_bytes。

inverse(a, m)：计算 a 在模 m 下的模反元素。

要求 a 和 m 是互质的。

返回值是 a 在模 m 下的模反元素。

isPrime(n, k=10)：检测一个数是否为素数。

参数 n 是要检测的数。

参数 k 是进行 Miller-Rabin 素性测试的次数，默认为 10。

bytes_to_long(s)：将字节串转换为对应的长整数。

参数 s 是要转换的字节串。

返回值是转换后的长整数。

long_to_bytes(n)：将长整数转换为对应的字节串。

参数 n 是要转换的长整数。

返回值是转换后的字节串。

（模幂运算：给定三个整数a、b和n，计算a的b次方后对n取模的结果。表示为：c ≡ a^b (mod n)，其中c是a的b次方对n取模的结果。（应用：快速幂，在tip里面有用python实现快速幂的代码））

（模反元素：数论中的一个概念，也称为乘法逆元或倒数。给定一个整数 a 和一个模数 m，如果存在一个整数 b，使得 (a * b) % m = 1，则 b 称为 a 在模 m 下的模反元素。）

2、Bytes_to_long（将文字翻译为长整数）

3、以下是一些 gmpy2 常用函数：

整数函数：

gmpy2.add(x, y)：返回 x + y 的结果。

gmpy2.sub(x, y)：返回 x - y 的结果。

gmpy2.mul(x, y)：返回 x * y 的结果。

gmpy2.div(x, y)：返回 x // y 的结果，即整数除法。

gmpy2.pow(x, y)：返回 x ** y 的结果，即幂运算。

Gmpy2.pow(x,y,z):返回（x**y）%z的值。          （当然，我们可以直接调用pow()函数，但是通过gmpy库调用的pow函数计算精度更大一些）

特别地，它也可以计算模反元素，即：pow（x,-1,y）计算x在模数y下的模反元素。数学原理：扩展欧几里得算法。如果x，y不互质的话，会返回ValueError 异常

gmpy2.invert(x, y)：返回 x 在模数 y 下的模反元素。

gmpy2.gcd(x, y)：返回 x 和 y 的最大公约数。

gmpy2.is_prime(x)：判断 x 是否为素数。

浮点数函数：

gmpy2.mpfr(x)：将浮点数 x 转换为高精度浮点数对象。

gmpy2.add(x, y)：返回 x + y 的结果。

gmpy2.sub(x, y)：返回 x - y 的结果。

gmpy2.mul(x, y)：返回 x * y 的结果。

gmpy2.div(x, y)：返回 x / y 的结果。

hashlib 是 Python 中用于进行哈希算法的标准库，提供了多种哈希算法的实现。下面是一些4、常用的 hashlib( Python 中用于进行哈希算法的标准库，提供了多种哈希算法的实现) 函数：

hashlib.md5(): 创建一个用于计算 MD5 哈希值的哈希对象。

hashlib.sha1(): 创建一个用于计算 SHA-1 哈希值的哈希对象。

hashlib.sha256(): 创建一个用于计算 SHA-256 哈希值的哈希对象。

hashlib.sha512(): 创建一个用于计算 SHA-512 哈希值的哈希对象。

hashlib.blake2b(): 创建一个用于计算 BLAKE2b 哈希值的哈希对象。

hashlib.blake2s(): 创建一个用于计算 BLAKE2s 哈希值的哈希对象。

这些函数返回的哈希对象可以用于对数据进行哈希计算。可以使用 update() 方法向哈希对象中添加数据，然后使用 hexdigest() 方法获取哈希值的十六进制表示。

例子：

import hashlib

data = b'Hello, world!'      （为什么加前缀b，详见tip）

hash_object = hashlib.sha256(data)

hex_digest = hash_object.hexdigest()

print(hex_digest)

 

三、题型

素数分解：在这种题型中，通常会给出一个RSA加密的公钥（包括模数n和指数e），要求参赛者找到并计算出私钥（包括质数p和q），素数分解题目可能会提供一些提示或者特定的条件

Eg1：

p = 1325465431

q = 152317153

e = 65537

计算出d,将d用MD5加密后包裹NSSCTF{}提交

解题过程：

import gmpy2

p=1325465431

q=152317153

e=65537

phi=(q-1)*(p-1)

d=gmpy2.invert(e,phi)

print(d)

之后将d用md5加密即可

 

共享素数：是指RSA加密时进行了两次加密，并且给出了加密钥e，两次加密的n1和n2，密文c

Eg1：

from Crypto.Util.number import *

from flag import *

n1=103835296409081751860770535514746586815395898427260334325680313648369132661057840680823295512236948953370895568419721331170834557812541468309298819497267746892814583806423027167382825479157951365823085639078738847647634406841331307035593810712914545347201619004253602692127370265833092082543067153606828049061

n2=115383198584677147487556014336448310721853841168758012445634182814180314480501828927160071015197089456042472185850893847370481817325868824076245290735749717384769661698895000176441497242371873981353689607711146852891551491168528799814311992471449640014501858763495472267168224015665906627382490565507927272073

e = 65537

m = bytes_to_long(flag)

c = pow(m, e, n1)

c = pow(c, e, n2)

print("c = %d" % c)

\# output

\#c=60406168302768860804211220055708551816238816061772464557956985699400782163597251861675967909246187833328847989530950308053492202064477410641014045601986036822451416365957817685047102703301347664879870026582087365822433436251615243854347490600004857861059245403674349457345319269266645006969222744554974358264

 



Tip：1、快速幂的python实现：

b=int(input("请输入底数："))

c=int(inpit("请输入指数："))

def fast(a,n):

​    if n==0:

​        return 1

​    elif n%2==0:

​        half=fast(a,n/2)

​        return half*half

​    else:

​        half=fast(a,n//2)

​        return a*half*half

‘用递归函数求快速幂，比较慢

 

def fast(a,n):

​    reult=1

​    while n>0:

​        if n%2==1:

​            result=reult*a

​        a=a*a

​        n=n//2

​        return result

‘用迭代方式求快速幂，比较快

​        

end=fast(b,c)

print(end)

input()

2、前缀b

在Python中，前缀为b的字符串表示字节字符串（bytes string）。字节字符串是以字节为单位表示的数据序列，而不是以字符为单位的字符串。

在Python 3中，字符串默认使用Unicode编码，即使用字符集来表示文本。然而，在某些情况下，我们需要处理原始的字节数据，例如处理二进制文件、网络传输的数据或与底层系统交互的数据。这时就可以使用字节字符串来表示这些数据。

通过在字符串前面添加b前缀，Python将其标识为字节字符串而不是Unicode字符串。这告诉Python解释器将字符串内容视为原始字节数据，而不是字符序列。例如，b'Hello, world!'表示一个由ASCII字符组成的字节序列。

字节字符串与普通字符串之间有一些重要的区别。普通字符串是不可变的，而字节字符串是可变的。此外，字节字符串中的元素是整数值（0-255），而不是Unicode字符。这使得字节字符串在处理二进制数据时更加灵活和高效。

因此，当你需要处理原始的字节数据时，可以使用字节字符串来表示它们，并在字符串前面添加b前缀来标识它是一个字节字符串。

原始字节数据和字符序列的区别：

表示方式：原始字节数据是以字节为单位表示的，每个字节可以表示0-255之间的整数值。它们通常用于表示二进制数据，如图像、音频、视频等。而字符序列是由字符组成的，可以使用不同的编码方案将字符映射为字节序列。

编码：原始字节数据不依赖于任何特定的字符编码，它们只是简单地表示字节的值。而字符序列需要使用字符编码方案将字符转换为字节序列，以便在存储和传输时能够正确地表示和解码字符。

可变性：原始字节数据是可变的，可以通过修改字节的值来改变数据。而字符序列是不可变的，一旦创建就不能直接修改其中的字符，只能通过创建新的序列来实现修改。

字符集支持：字符序列可以表示各种字符集中的字符，如ASCII、Unicode等。每个字符可以由一个或多个字节表示，具体取决于所使用的编码方案。而原始字节数据没有字符集的概念，它们只是简单地表示字节值，可以包含任意的二进制数据。

什么时候使用字节字符串：

1、处理二进制数据：当需要处理二进制数据，如图像、音频、视频、网络通信数据等时，字节字符串是一种常用的表示方式。它们可以直接存储和传输原始的字节数据，而无需进行字符编码和解码操作。

2、与外部系统或库进行交互：在与外部系统或库进行交互时，有时需要将数据表示为字节字符串。例如，当与底层操作系统、网络协议、硬件设备或其他编程语言的库进行交互时，常常需要使用字节字符串来传递和接收数据。

3、文件处理：在读取或写入二进制文件时，可以使用字节字符串来处理文件的原始字节数据。这对于处理图像文件、音频文件、压缩文件等非文本文件非常有用。

4、密码学和加密：在密码学和加密领域，字节字符串经常用于表示密钥、哈希值、加密算法的输入和输出等。这是因为加密算法通常基于字节级别的操作。

5、性能优化：在某些情况下，使用字节字符串可以提高程序的性能。与文本字符串相比，字节字符串在处理和操作二进制数据时更加高效。

哈希函数：哈希函数是一种将任意长度的输入数据映射到固定长度输出的函数。它接受输入数据，并通过特定的算法对数据进行处理，生成一个称为哈希值的固定长度输出。

哈希函数的设计目标是使得不同的输入数据尽可能地产生不同的哈希值，同时保证相同的输入数据始终生成相同的哈希值。这种性质被称为"确定性"。此外，好的哈希函数还应该具有以下特点：

快速计算：哈希函数应该能够在合理的时间内计算出哈希值，即使输入数据非常大。

均匀分布：好的哈希函数应该尽可能地将输入数据的不同部分均匀地映射到哈希值的不同位上。这样可以最大程度地减少冲突，即不同的输入数据生成相同的哈希值的概率。

雪崩效应：好的哈希函数应该对输入数据的微小变化产生显著不同的哈希值。即使输入数据只有一个字节的差异，生成的哈希值也应该完全不同。

 